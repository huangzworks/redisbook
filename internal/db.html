<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>数据库 &mdash; Redis 设计与实现</title>
    
    <link rel="stylesheet" href="../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Redis 设计与实现" href="../index.html" />
    <link rel="next" title="RDB" href="rdb.html" />
    <link rel="prev" title="慢查询日志" href="../feature/slowlog.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="rdb.html" title="RDB"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../feature/slowlog.html" title="慢查询日志"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="db-chapter">
<span id="id1"></span><h1>数据库<a class="headerlink" href="#db-chapter" title="Permalink to this headline">¶</a></h1>
<p>本章将对 Redis 数据库的构造和实现进行讨论。</p>
<p>除了说明数据库是如何储存数据对象之外，本章还会讨论键的过期信息是如何保存，而 Redis 又是如何删除过期键的。</p>
<div class="section" id="id2">
<h2>数据库的结构<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Redis 中的每个数据库，都由一个 <code class="docutils literal"><span class="pre">redis.h/redisDb</span></code> 结构表示：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>

    <span class="c1">// 保存着数据库以整数表示的号码</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

    <span class="c1">// 保存着数据库中的所有键值对数据</span>
    <span class="c1">// 这个属性也被称为键空间（key space）</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">dict</span><span class="p">;</span>

    <span class="c1">// 保存着键的过期信息</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">expires</span><span class="p">;</span>

    <span class="c1">// 实现列表阻塞原语，如 BLPOP</span>
    <span class="c1">// 在列表类型一章有详细的讨论</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">blocking_keys</span><span class="p">;</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">ready_keys</span><span class="p">;</span>

    <span class="c1">// 用于实现 WATCH 命令</span>
    <span class="c1">// 在事务章节有详细的讨论</span>
    <span class="n">dict</span> <span class="o">*</span><span class="n">watched_keys</span><span class="p">;</span>

<span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</pre></div>
</div>
<p>下文将详细讨论  <code class="docutils literal"><span class="pre">id</span></code> 、 <code class="docutils literal"><span class="pre">dict</span></code> 和 <code class="docutils literal"><span class="pre">expires</span></code> 三个属性，
以及针对这三个属性所执行的数据库操作。</p>
</div>
<div class="section" id="id3">
<h2>数据库的切换<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">redisDb</span></code> 结构的 <code class="docutils literal"><span class="pre">id</span></code> 域保存着数据库的号码。</p>
<p>这个号码很容易让人将它和切换数据库的 <a class="reference external" href="http://redis.readthedocs.org/en/latest/connection/select.html#select" title="(in Redis 命令参考 v2.8)"><span>SELECT</span></a> 命令联系在一起，
但是，
实际上，
<code class="docutils literal"><span class="pre">id</span></code> 属性并不是用来实现 <a class="reference external" href="http://redis.readthedocs.org/en/latest/connection/select.html#select" title="(in Redis 命令参考 v2.8)"><span>SELECT</span></a> 命令，
而是给 Redis 内部程序使用的。</p>
<p>当 Redis 服务器初始化时，
它会创建出 <code class="docutils literal"><span class="pre">redis.h/REDIS_DEFAULT_DBNUM</span></code> 个数据库，
并将所有数据库保存到 <code class="docutils literal"><span class="pre">redis.h/redisServer.db</span></code> 数组中，
每个数据库的 <code class="docutils literal"><span class="pre">id</span></code> 为从 <code class="docutils literal"><span class="pre">0</span></code> 到 <code class="docutils literal"><span class="pre">REDIS_DEFAULT_DBNUM</span> <span class="pre">-</span> <span class="pre">1</span></code> 的值。</p>
<p>当执行 <code class="docutils literal"><span class="pre">SELECT</span> <span class="pre">number</span></code> 命令时，程序直接使用 <code class="docutils literal"><span class="pre">redisServer.db[number]</span></code> 来切换数据库。</p>
<p>但是，
一些内部程序，
比如 AOF 程序、复制程序和 RDB 程序，
需要知道当前数据库的号码，
如果没有 <code class="docutils literal"><span class="pre">id</span></code> 域的话，
程序就只能在当前使用的数据库的指针，
和 <code class="docutils literal"><span class="pre">redisServer.db</span></code> 数组中所有数据库的指针进行对比，
以此来弄清楚自己正在使用的是那个数据库。</p>
<p>以下伪代码描述了这个对比过程：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">PSEUDO_GET_CURRENT_DB_NUMBER</span><span class="p">(</span><span class="n">current_db_pointer</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">db_pointer</span> <span class="ow">in</span> <span class="n">redisServer</span><span class="o">.</span><span class="n">db</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">db_pointer</span> <span class="o">==</span> <span class="n">current_db_pointer</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>
</pre></div>
</div>
<p>有了 <code class="docutils literal"><span class="pre">id</span></code> 域的话，
程序就可以通过读取 <code class="docutils literal"><span class="pre">id</span></code> 域来了解自己正在使用的是哪个数据库，
这样就不用对比指针那么麻烦了。</p>
</div>
<div class="section" id="id4">
<h2>数据库键空间<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>因为 Redis 是一个键值对数据库（key-value pairs database），
所以它的数据库本身也是一个字典（俗称 key space）：</p>
<ul class="simple">
<li>字典的键是一个<a class="reference internal" href="../datatype/string.html#string-chapter"><span>字符串</span></a>对象。</li>
<li>字典的值则可以是包括<a class="reference internal" href="../datatype/string.html#string-chapter"><span>字符串</span></a>、<a class="reference internal" href="../datatype/list.html#list-chapter"><span>列表</span></a>、<a class="reference internal" href="../datatype/hash.html#hash-chapter"><span>哈希表</span></a>、<a class="reference internal" href="../datatype/set.html#set-chapter"><span>集合</span></a>或<a class="reference internal" href="../datatype/sorted_set.html#sorted-set-chapter"><span>有序集</span></a>在内的任意一种 Redis 类型对象。</li>
</ul>
<p>在 <code class="docutils literal"><span class="pre">redisDb</span></code> 结构的 <code class="docutils literal"><span class="pre">dict</span></code> 属性中，保存着数据库的所有键值对数据。</p>
<p>下图展示了一个包含 <code class="docutils literal"><span class="pre">number</span></code> 、 <code class="docutils literal"><span class="pre">book</span></code> 、 <code class="docutils literal"><span class="pre">message</span></code> 三个键的数据库 ——
其中 <code class="docutils literal"><span class="pre">number</span></code> 键是一个列表，列表中包含三个整数值；
<code class="docutils literal"><span class="pre">book</span></code> 键是一个哈希表，表中包含三个键值对；
而 <code class="docutils literal"><span class="pre">message</span></code> 键则指向另一个字符串：</p>
<p class="graphviz">
<img src="../_images/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
</div>
<div class="section" id="id5">
<h2>键空间的操作<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>因为数据库本身是一个字典，
所以对数据库的操作基本上都是对字典的操作，
加上以下一些维护操作：</p>
<ul class="simple">
<li>更新键的命中率和不命中率，这个值可以用 <a class="reference external" href="http://redis.readthedocs.org/en/latest/server/info.html#info" title="(in Redis 命令参考 v2.8)"><span>INFO</span></a> 命令查看；</li>
<li>更新键的 LRU 时间，这个值可以用 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/object.html#object" title="(in Redis 命令参考 v2.8)"><span>OBJECT</span></a> 命令来查看；</li>
<li>删除过期键（稍后会详细说明）；</li>
<li>如果键被修改了的话，那么将键设为脏（用于事务监视），并将服务器设为脏（等待 RDB 保存）；</li>
<li>将对键的修改发送到 AOF 文件和附属节点，保持数据库状态的一致；</li>
</ul>
<p>作为例子，以下几个小节会展示键的添加、删除、更新、取值等几个主要操作。</p>
<div class="section" id="id6">
<h3>添加新键<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>添加一个新键对到数据库，
实际上就是将一个新的键值对添加到键空间字典中，
其中键为字符串对象，
而值则是任意一种 Redis 类型值对象。</p>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<p class="graphviz">
<img src="../_images/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
<p>那么在客户端执行 <code class="docutils literal"><span class="pre">SET</span> <span class="pre">date</span> <span class="pre">2013.2.1</span></code> 命令之后，数据库更新为下图状态：</p>
<p class="graphviz">
<img src="../_images/graphviz-574f2a7d4969f29d50d0b3a5fba6f152ec118676.svg" alt="digraph db_after_insert_new_key {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; |&lt;date&gt;StringObject\n \&quot;date\&quot; |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    date [label =  &quot;&lt;head&gt;StringObject | \&quot;2013.2.1\&quot;&quot;, fillcolor = &quot;#FFC1C1&quot;];
    
    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:date -&gt; date;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
</div>
<div class="section" id="id7">
<h3>删除键<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>删除数据库中的一个键，
实际上就是删除字典空间中对应的键对象和值对象。</p>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<p class="graphviz">
<img src="../_images/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
<p>那么在客户端执行 <code class="docutils literal"><span class="pre">DEL</span> <span class="pre">message</span></code> 命令之后，数据库更新为下图状态：</p>
<p class="graphviz">
<img src="../_images/graphviz-e5ee0986e5626ab032382bce64e2b41a60008e25.svg" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; | NULL&quot;, fillcolor = &quot;#FFC1C1&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
</div>
<div class="section" id="id8">
<h3>更新键<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>当对一个已存在于数据库的键执行更新操作时，
数据库释放键原来的值对象，
然后将指针指向新的值对象。</p>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<p class="graphviz">
<img src="../_images/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
<p>那么在客户端执行 <code class="docutils literal"><span class="pre">SET</span> <span class="pre">message</span> <span class="pre">&quot;blah</span> <span class="pre">blah&quot;</span></code> 命令之后，数据库更新为下图状态：</p>
<p class="graphviz">
<img src="../_images/graphviz-baa230ed027a28ac6bb0de0767a91876c1993195.svg" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;blah blah\&quot;&quot;, fillcolor = &quot;#FFC1C1&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
</div>
<div class="section" id="id9">
<h3>取值<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>在数据库中取值实际上就是在字典空间中取值，
再加上一些额外的类型检查：</p>
<ul class="simple">
<li>键不存在，返回空回复；</li>
<li>键存在，且类型正确，按照通讯协议返回值对象；</li>
<li>键存在，但类型不正确，返回类型错误。</li>
</ul>
<p>举个例子，如果数据库的目前状态如下图所示（和前面展示的数据库状态图一样）：</p>
<p class="graphviz">
<img src="../_images/graphviz-f7d41d371c9e008ce371e7303e6bb07fb8a48257.svg" alt="digraph db {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;
}" />
</p>
<p>当客户端执行 <code class="docutils literal"><span class="pre">GET</span> <span class="pre">message</span></code> 时，服务器返回 <code class="docutils literal"><span class="pre">&quot;hello</span> <span class="pre">moto&quot;</span></code> 。</p>
<p>当客户端执行 <code class="docutils literal"><span class="pre">GET</span> <span class="pre">not-exists-key</span></code> 时，服务器返回空回复。</p>
<p>当服务器执行 <code class="docutils literal"><span class="pre">GET</span> <span class="pre">book</span></code> 时，服务器返回类型错误。</p>
</div>
<div class="section" id="id10">
<h3>其他操作<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>除了上面展示的键值操作之外，还有很多针对数据库本身的命令，也是通过对键空间进行处理来完成的：</p>
<ul class="simple">
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/server/flushdb.html#flushdb" title="(in Redis 命令参考 v2.8)"><span>FLUSHDB</span></a> 命令：删除键空间中的所有键值对。</li>
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/key/randomkey.html#randomkey" title="(in Redis 命令参考 v2.8)"><span>RANDOMKEY</span></a> 命令：从键空间中随机返回一个键。</li>
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/server/dbsize.html#dbsize" title="(in Redis 命令参考 v2.8)"><span>DBSIZE</span></a> 命令：返回键空间中键值对的数量。</li>
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/key/exists.html#exists" title="(in Redis 命令参考 v2.8)"><span>EXISTS</span></a> 命令：检查给定键是否存在于键空间中。</li>
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/key/rename.html#rename" title="(in Redis 命令参考 v2.8)"><span>RENAME</span></a> 命令：在键空间中，对给定键进行改名。</li>
</ul>
<p>等等。</p>
</div>
</div>
<div class="section" id="id11">
<h2>键的过期时间<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>在前面的内容中，
我们讨论了很多涉及数据库本身、以及对数据库中的键值对进行处理的操作，
但是，
关于数据库如何保存键的过期时间，
以及如何处理过期键这一问题，
我们还没有讨论到。</p>
<p>通过 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/expire.html#expire" title="(in Redis 命令参考 v2.8)"><span>EXPIRE</span></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/pexpire.html#pexpire" title="(in Redis 命令参考 v2.8)"><span>PEXPIRE</span></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/expireat.html#expireat" title="(in Redis 命令参考 v2.8)"><span>EXPIREAT</span></a> 和 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/pexpireat.html#pexpireat" title="(in Redis 命令参考 v2.8)"><span>PEXPIREAT</span></a> 四个命令，
客户端可以给某个存在的键设置过期时间，
当键的过期时间到达时，
键就不再可用：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SETEX</span> <span class="n">key</span> <span class="mi">5</span> <span class="n">value</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">key</span>
<span class="s">&quot;value&quot;</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">key</span>   <span class="c1">// 5 秒过后</span>
<span class="p">(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>命令 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/ttl.html#ttl" title="(in Redis 命令参考 v2.8)"><span>TTL</span></a> 和 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/pttl.html#pttl" title="(in Redis 命令参考 v2.8)"><span>PTTL</span></a> 则用于返回给定键距离过期还有多长时间：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SETEX</span> <span class="n">key</span> <span class="mi">10086</span> <span class="n">value</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">TTL</span> <span class="n">key</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">10082</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">PTTL</span> <span class="n">key</span>
<span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">10068998</span>
</pre></div>
</div>
<p>在接下来的内容中，
我们将探讨和键的过期时间相关的问题：
比如键的过期时间是如何保存的，
而过期键又是如何被删除的，
等等。</p>
</div>
<div class="section" id="id12">
<h2>过期时间的保存<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>在数据库中，
所有键的过期时间都被保存在 <code class="docutils literal"><span class="pre">redisDb</span></code> 结构的 <code class="docutils literal"><span class="pre">expires</span></code> 字典里：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisDb</span> <span class="p">{</span>

    <span class="c1">// ...</span>

    <span class="n">dict</span> <span class="o">*</span><span class="n">expires</span><span class="p">;</span>

    <span class="c1">// ...</span>

<span class="p">}</span> <span class="n">redisDb</span><span class="p">;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">expires</span></code> 字典的键是一个指向 <code class="docutils literal"><span class="pre">dict</span></code> 字典（键空间）里某个键的指针，
而字典的值则是键所指向的数据库键的到期时间，
这个值以 <code class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></code> 类型表示。</p>
<p>下图展示了一个含有三个键的数据库，其中 <code class="docutils literal"><span class="pre">number</span></code> 和 <code class="docutils literal"><span class="pre">book</span></code> 两个键带有过期时间：</p>
<p class="graphviz">
<img src="../_images/graphviz-db4eb6451979faf62da12bc0943cd00a9e0097e4.svg" alt="digraph db_with_expire_time {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id |&lt;dict&gt; dict |&lt;expires&gt; expires | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    // dict

    dict [label = &quot;&lt;head&gt;dict\n(key space) |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; |&lt;message&gt;StringObject\n \&quot;message\&quot;&quot;, fillcolor = &quot;#95BBE3&quot;];

    number [label = &quot;&lt;head&gt;ListObject | { 123 | 456 | 789 }&quot;, fillcolor = &quot;#FADCAD&quot;];

    book [label = &quot;&lt;head&gt;HashObject |&lt;name&gt;StringObject\n \&quot;name\&quot; |&lt;author&gt;StringObject\n \&quot;author\&quot; |&lt;publisher&gt;StringObject\n \&quot;publisher\&quot;&quot;, fillcolor = &quot;#F2F2F2&quot;];

    book_name [label = &quot;&lt;head&gt;StringObject | \&quot;Mastering C++ in 21 days\&quot;&quot;];
    book_author [label = &quot;&lt;head&gt;StringObject | \&quot;Someone\&quot;&quot;];
    book_publisher [label = &quot;&lt;head&gt;StringObject | \&quot;Oh-Really? Publisher\&quot;&quot;];

    message [label = &quot;&lt;head&gt;StringObject | \&quot;hello moto\&quot;&quot;];

    // dict edge

    redisDb:dict -&gt; dict:head;

    dict:number -&gt; number:head;
    dict:book -&gt; book:head;
    dict:message -&gt; message:head;

    book:name -&gt; book_name:head;
    book:author -&gt; book_author:head;
    book:publisher -&gt; book_publisher:head;

    // expires

    expires [label = &quot;&lt;head&gt;dict |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; | NULL &quot;, fillcolor = &quot;#95BBE3&quot;];

    expire_of_number [label = &quot;&lt;head&gt;long long | 1360454400000 &quot;];

    expire_of_book [label = &quot;&lt;head&gt;long long | 1360800000000 &quot;];

    // expires edge

    redisDb:expires -&gt; expires:head;

    expires:number -&gt; expire_of_number:head;
    expires:book -&gt; expire_of_book:head;

}" />
</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">为了展示的方便，
图中重复出现了两次 <code class="docutils literal"><span class="pre">number</span></code> 键和 <code class="docutils literal"><span class="pre">book</span></code> 键。
在实际中，
键空间字典的键和过期时间字典的键都指向同一个字符串对象，
所以不会浪费任何空间。</p>
</div>
</div>
<div class="section" id="id13">
<h2>设置生存时间<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p>Redis 有四个命令可以设置键的生存时间（可以存活多久）和过期时间（什么时候到期）：</p>
<ul class="simple">
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/key/expire.html#expire" title="(in Redis 命令参考 v2.8)"><span>EXPIRE</span></a> 以秒为单位设置键的生存时间；</li>
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/key/pexpire.html#pexpire" title="(in Redis 命令参考 v2.8)"><span>PEXPIRE</span></a> 以毫秒为单位设置键的生存时间；</li>
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/key/expireat.html#expireat" title="(in Redis 命令参考 v2.8)"><span>EXPIREAT</span></a> 以秒为单位，设置键的过期 UNIX 时间戳；</li>
<li><a class="reference external" href="http://redis.readthedocs.org/en/latest/key/pexpireat.html#pexpireat" title="(in Redis 命令参考 v2.8)"><span>PEXPIREAT</span></a> 以毫秒为单位，设置键的过期 UNIX 时间戳。</li>
</ul>
<p>虽然有那么多种不同单位和不同形式的设置方式，
但是 <code class="docutils literal"><span class="pre">expires</span></code> 字典的值只保存“以毫秒为单位的过期 UNIX 时间戳”，
这就是说，
通过进行转换，
所有命令的效果最后都和 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/pexpireat.html#pexpireat" title="(in Redis 命令参考 v2.8)"><span>PEXPIREAT</span></a> 命令的效果一样。</p>
<p>举个例子，从 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/expire.html#expire" title="(in Redis 命令参考 v2.8)"><span>EXPIRE</span></a> 命令到 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/pexpireat.html#pexpireat" title="(in Redis 命令参考 v2.8)"><span>PEXPIREAT</span></a> 命令的转换可以用伪代码表示如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">EXPIRE</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">sec</span><span class="p">):</span>

    <span class="c"># 将 TTL 从秒转换为毫秒</span>
    <span class="n">ms</span> <span class="o">=</span> <span class="n">sec_to_ms</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span>

    <span class="c"># 获取以毫秒计算的当前 UNIX 时间戳</span>
    <span class="n">ts_in_ms</span> <span class="o">=</span> <span class="n">get_current_unix_timestamp_in_ms</span><span class="p">()</span>

    <span class="c"># 毫秒 TTL 加上毫秒时间戳，就是 key 到期的时间戳</span>
    <span class="n">PEXPIREAT</span><span class="p">(</span><span class="n">ms</span> <span class="o">+</span> <span class="n">ts_in_ms</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
<p>其他函数的转换方式也是类似的。</p>
<p>作为例子，
下图展示了一个 <code class="docutils literal"><span class="pre">expires</span></code> 字典示例，
字典中 <code class="docutils literal"><span class="pre">number</span></code> 键的过期时间是 2013 年 2 月 10 日（农历新年），
而 <code class="docutils literal"><span class="pre">book</span></code> 键的过期时间则是 2013 年 2 月 14 日（情人节）：</p>
<p class="graphviz">
<img src="../_images/graphviz-3bd6730e0529a24b3a3d6e11a751b395e2039717.svg" alt="digraph expires {

    rankdir = LR;

    node [shape = record, style =filled];

    edge [style = bold];

    // node

    redisDb [label = &quot;redisDb | id | ... |&lt;expires&gt; expires | ...&quot;, fillcolor = &quot;#A8E270&quot;];

    // expires

    expires [label = &quot;&lt;head&gt;dict |&lt;number&gt;StringObject\n \&quot;number\&quot; | NULL |&lt;book&gt;StringObject\n \&quot;book\&quot; | NULL &quot;, fillcolor = &quot;#95BBE3&quot;];

    expire_of_number [label = &quot;&lt;head&gt;long long | 1360454400000 &quot;];

    expire_of_book [label = &quot;&lt;head&gt;long long | 1360800000000 &quot;];

    // expires edge

    redisDb:expires -&gt; expires:head;

    expires:number -&gt; expire_of_number:head;
    expires:book -&gt; expire_of_book:head;

}" />
</p>
<p>这两个键的过期时间可能是用以上四个命令的任意一个设置的，
但它们都以统一的格式被保存在 <code class="docutils literal"><span class="pre">expires</span></code> 字典中。</p>
</div>
<div class="section" id="id14">
<h2>过期键的判定<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>通过 <code class="docutils literal"><span class="pre">expires</span></code> 字典，
可以用以下步骤检查某个键是否过期：</p>
<ol class="arabic simple">
<li>检查键是否存在于 <code class="docutils literal"><span class="pre">expires</span></code> 字典：如果存在，那么取出键的过期时间；</li>
<li>检查当前 UNIX 时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则，键未过期。</li>
</ol>
<p>可以用伪代码来描述这一过程：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">is_expired</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>

    <span class="c"># 取出键的过期时间</span>
    <span class="n">key_expire_time</span> <span class="o">=</span> <span class="n">expires</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="c"># 如果过期时间不为空，并且当前时间戳大于过期时间，那么键已经过期</span>
    <span class="k">if</span> <span class="n">expire_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">current_timestamp</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">key_expire_time</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="c"># 否则，键未过期或没有设置过期时间</span>
    <span class="k">return</span> <span class="bp">False</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h2>过期键的清除<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>我们知道了过期时间保存在 <code class="docutils literal"><span class="pre">expires</span></code> 字典里，
又知道了该如何判定一个键是否过期，
现在剩下的问题是，
如果一个键是过期的，
那它什么时候会被删除？</p>
<p>这个问题有三种可能的答案：</p>
<ol class="arabic simple">
<li>定时删除：在设置键的过期时间时，创建一个定时事件，当过期时间到达时，由事件处理器自动执行键的删除操作。</li>
<li>惰性删除：放任键过期不管，但是在每次从 <code class="docutils literal"><span class="pre">dict</span></code> 字典中取出键值时，要检查键是否过期，如果过期的话，就删除它，并返回空；如果没过期，就返回键值。</li>
<li>定期删除：每隔一段时间，对 <code class="docutils literal"><span class="pre">expires</span></code> 字典进行检查，删除里面的过期键。</li>
</ol>
<div class="section" id="id16">
<h3>定时删除<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>定时删除策略对内存是最友好的：
因为它保证过期键会在第一时间被删除，
过期键所消耗的内存会立即被释放。</p>
<p>这种策略的缺点是，
它对 CPU 时间是最不友好的：
因为删除操作可能会占用大量的 CPU 时间 ——
在内存不紧张、但是 CPU 时间非常紧张的时候
（比如说，进行交集计算或排序的时候），
将 CPU 时间花在删除那些和当前任务无关的过期键上，
这种做法毫无疑问会是低效的。</p>
<p>除此之外，
目前 Redis 事件处理器对时间事件的实现方式 —— 无序链表，
查找一个时间复杂度为 <span class="math">\(O(N)\)</span>  —— 并不适合用来处理大量时间事件。</p>
</div>
<div class="section" id="id17">
<h3>惰性删除<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>惰性删除对 CPU 时间来说是最友好的：
它只会在取出键时进行检查，
这可以保证删除操作只会在非做不可的情况下进行 ——
并且删除的目标仅限于当前处理的键，
这个策略不会在删除其他无关的过期键上花费任何 CPU 时间。</p>
<p>惰性删除的缺点是，
它对内存是最不友好的：
如果一个键已经过期，
而这个键又仍然保留在数据库中，
那么 <code class="docutils literal"><span class="pre">dict</span></code> 字典和 <code class="docutils literal"><span class="pre">expires</span></code> 字典都需要继续保存这个键的信息，
只要这个过期键不被删除，
它占用的内存就不会被释放。</p>
<p>在使用惰性删除策略时，
如果数据库中有非常多的过期键，
但这些过期键又正好没有被访问的话，
那么它们就永远也不会被删除（除非用户手动执行），
这对于性能非常依赖于内存大小的 Redis 来说，
肯定不是一个好消息。</p>
<p>举个例子，
对于一些按时间点来更新的数据，
比如日志（log），
在某个时间点之后，
对它们的访问就会大大减少，
如果大量的这些过期数据积压在数据库里面，
用户以为它们已经过期了（已经被删除了），
但实际上这些键却没有真正的被删除（内存也没有被释放），
那结果肯定是非常糟糕。</p>
</div>
<div class="section" id="id18">
<h3>定期删除<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>从上面对定时删除和惰性删除的讨论来看，
这两种删除方式在单一使用时都有明显的缺陷：
定时删除占用太多 CPU 时间，
惰性删除浪费太多内存。</p>
<p>定期删除是这两种策略的一种折中：</p>
<ul class="simple">
<li>它每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，籍此来减少删除操作对 CPU 时间的影响。</li>
<li>另一方面，通过定期删除过期键，它有效地减少了因惰性删除而带来的内存浪费。</li>
</ul>
</div>
<div class="section" id="redis">
<h3>Redis 使用的策略<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h3>
<p>Redis 使用的过期键删除策略是惰性删除加上定期删除，
这两个策略相互配合，可以很好地在合理利用 CPU 时间和节约内存空间之间取得平衡。</p>
<p>因为前面已经说了这两个策略的概念了，下面两节就来探讨这两个策略在 Redis 中的具体实现。</p>
</div>
</div>
<div class="section" id="id19">
<h2>过期键的惰性删除策略<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<p>实现过期键惰性删除策略的核心是 <code class="docutils literal"><span class="pre">db.c/expireIfNeeded</span></code> 函数 ——
所有命令在读取或写入数据库之前，程序都会调用 <code class="docutils literal"><span class="pre">expireIfNeeded</span></code> 对输入键进行检查，
并将过期键删除：</p>
<p class="graphviz">
<img src="../_images/graphviz-efb7f7ae1a793feea33285531dfe0023f3017b90.svg" alt="digraph expire_check {
    
    node [style = filled, shape = plaintext];

    edge [style = bold];

    // node

    write_commands [label = &quot;SET 、\n LPUSH 、\n SADD 、 \n 等等&quot;, fillcolor = &quot;#FADCAD&quot;];

    read_commands [label = &quot;GET 、\n LRANGE 、\n SMEMBERS 、 \n 等等&quot;, fillcolor = &quot;#FADCAD&quot;];

    expire_if_needed [label = &quot;调用 expire_if_needed() \n 删除过期键&quot;, shape = box, fillcolor = &quot;#A8E270&quot;];

    process [label = &quot;执行实际的命令流程&quot;];

    // edge

    write_commands -&gt; expire_if_needed [label = &quot;写请求&quot;];

    read_commands -&gt; expire_if_needed [label = &quot;读请求&quot;];

    expire_if_needed -&gt; process;

}" />
</p>
<p>比如说， <code class="docutils literal"><span class="pre">GET</span></code> 命令的执行流程可以用下图来表示：</p>
<p class="graphviz">
<img src="../_images/graphviz-acca43b0dd583eb92a1ce7193dc6b9bb14e9c0f9.svg" alt="digraph get_with_expire {

    node [style = filled, shape = plaintext];

    edge [style = bold];

    // node
  
    get [label = &quot;GET key&quot;, fillcolor = &quot;#FADCAD&quot;];

    expire_if_needed [label = &quot;调用\n expire_if_needed() \n 如果键已经过期 \n 那么将它删除&quot;, shape = diamond, fillcolor = &quot;#A8E270&quot;];

    expired_and_deleted [label = &quot;key 不存在\n 向客户端返回 NIL&quot;];

    not_expired [label = &quot;向客户端返回 key 的值&quot;];

    get -&gt; expire_if_needed;

    expire_if_needed -&gt; expired_and_deleted [label = &quot;已过期&quot;];
    expire_if_needed -&gt; not_expired [label = &quot;未过期&quot;];

}" />
</p>
<p><code class="docutils literal"><span class="pre">expireIfNeeded</span></code> 的作用是，
如果输入键已经过期的话，
那么将键、键的值、键保存在 <code class="docutils literal"><span class="pre">expires</span></code> 字典中的过期时间都删除掉。</p>
<p>用伪代码描述的 <code class="docutils literal"><span class="pre">expireIfNeeded</span></code> 定义如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">expireIfNeeded</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>

    <span class="c"># 对过期键执行以下操作 。。。</span>
    <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">is_expired</span><span class="p">():</span>

        <span class="c"># 从键空间中删除键值对</span>
        <span class="n">db</span><span class="o">.</span><span class="n">dict</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c"># 删除键的过期时间</span>
        <span class="n">db</span><span class="o">.</span><span class="n">expires</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c"># 将删除命令传播到 AOF 文件和附属节点</span>
        <span class="n">propagateDelKeyToAofAndReplication</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h2>过期键的定期删除策略<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
<p>对过期键的定期删除由 <code class="docutils literal"><span class="pre">redis.c/activeExpireCycle</span></code> 函执行：
每当 Redis 的例行处理程序 <code class="docutils literal"><span class="pre">serverCron</span></code> 执行时，
<code class="docutils literal"><span class="pre">activeExpireCycle</span></code> 都会被调用 ——
这个函数在规定的时间限制内，
尽可能地遍历各个数据库的 <code class="docutils literal"><span class="pre">expires</span></code> 字典，
随机地检查一部分键的过期时间，
并删除其中的过期键。</p>
<p>整个过程可以用伪代码描述如下：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">activeExpireCycle</span><span class="p">():</span>

    <span class="c"># 遍历数据库（不一定能全部都遍历完，看时间是否足够）</span>
    <span class="k">for</span> <span class="n">db</span> <span class="ow">in</span> <span class="n">server</span><span class="o">.</span><span class="n">db</span><span class="p">:</span>

        <span class="c"># MAX_KEY_PER_DB 是一个 DB 最大能处理的 key 个数</span>
        <span class="c"># 它保证时间不会全部用在个别的 DB 上（避免饥饿）</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_KEY_PER_DB</span><span class="p">):</span>

            <span class="c"># 数据库为空，跳出 while ，处理下个 DB</span>
            <span class="k">if</span> <span class="n">db</span><span class="o">.</span><span class="n">is_empty</span><span class="p">():</span> <span class="k">break</span>

            <span class="c"># 随机取出一个带 TTL 的键</span>
            <span class="n">key_with_ttl</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">expires</span><span class="o">.</span><span class="n">get_random_key</span><span class="p">()</span>

            <span class="c"># 检查键是否过期，如果是的话，将它删除</span>
            <span class="k">if</span> <span class="n">is_expired</span><span class="p">(</span><span class="n">key_with_ttl</span><span class="p">):</span>
                <span class="n">db</span><span class="o">.</span><span class="n">deleteExpiredKey</span><span class="p">(</span><span class="n">key_with_ttl</span><span class="p">)</span>

            <span class="c"># 当执行时间到达上限，函数就返回，不再继续</span>
            <span class="c"># 这确保删除操作不会占用太多的 CPU 时间</span>
            <span class="k">if</span> <span class="n">reach_time_limit</span><span class="p">():</span> <span class="k">return</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="aof-rdb">
<h2>过期键对 AOF 、RDB 和复制的影响<a class="headerlink" href="#aof-rdb" title="Permalink to this headline">¶</a></h2>
<p>前面的内容讨论了过期键对 CPU 时间和内存的影响，现在，是时候说说过期键在 RDB 文件、 AOF 文件、 AOF 重写以及复制中的影响了：</p>
<p>过期键会被保存在更新后的 RDB 文件、 AOF 文件或者重写后的 AOF 文件里面吗？</p>
<p>附属节点会会如何处理过期键？处理的方式和主节点一样吗？</p>
<p>以上这些问题就是本节要解答的。</p>
<div class="section" id="rdb">
<h3>更新后的 RDB 文件<a class="headerlink" href="#rdb" title="Permalink to this headline">¶</a></h3>
<p>在创建新的 RDB 文件时，程序会对键进行检查，过期的键不会被写入到更新后的 RDB 文件中。</p>
<p>因此，过期键对更新后的 RDB 文件没有影响。</p>
</div>
<div class="section" id="aof">
<h3>AOF 文件<a class="headerlink" href="#aof" title="Permalink to this headline">¶</a></h3>
<p>在键已经过期，但是还没有被惰性删除或者定期删除之前，这个键不会产生任何影响，AOF 文件也不会因为这个键而被修改。</p>
<p>当过期键被惰性删除、或者定期删除之后，程序会向 AOF 文件追加一条 <code class="docutils literal"><span class="pre">DEL</span></code> 命令，来显式地记录该键已被删除。</p>
<p>举个例子，
如果客户端使用 <code class="docutils literal"><span class="pre">GET</span> <span class="pre">message</span></code> 试图访问 <code class="docutils literal"><span class="pre">message</span></code> 键的值，
但 <code class="docutils literal"><span class="pre">message</span></code> 已经过期了，
那么服务器执行以下三个动作：</p>
<ol class="arabic simple">
<li>从数据库中删除 <code class="docutils literal"><span class="pre">message</span></code> ；</li>
<li>追加一条 <code class="docutils literal"><span class="pre">DEL</span> <span class="pre">message</span></code> 命令到 AOF 文件；</li>
<li>向客户端返回 <code class="docutils literal"><span class="pre">NIL</span></code> 。</li>
</ol>
</div>
<div class="section" id="id21">
<h3>AOF 重写<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>和 RDB 文件类似，
当进行 AOF 重写时，
程序会对键进行检查，
过期的键不会被保存到重写后的 AOF 文件。</p>
<p>因此，过期键对重写后的 AOF 文件没有影响。</p>
</div>
<div class="section" id="id22">
<h3>复制<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h3>
<p>当服务器带有附属节点时，
过期键的删除由主节点统一控制：</p>
<ul class="simple">
<li>如果服务器是主节点，那么它在删除一个过期键之后，会显式地向所有附属节点发送一个 <code class="docutils literal"><span class="pre">DEL</span></code> 命令。</li>
<li>如果服务器是附属节点，那么当它碰到一个过期键的时候，它会向程序返回键已过期的回复，但并不真正的删除过期键。因为程序只根据键是否已经过期、而不是键是否已经被删除来决定执行流程，所以这种处理并不影响命令的正确执行结果。当接到从主节点发来的 <code class="docutils literal"><span class="pre">DEL</span></code> 命令之后，附属节点才会真正的将过期键删除掉。</li>
</ul>
<p>附属节点不自主对键进行删除是为了和主节点的数据保持绝对一致，
因为这个原因，
当一个过期键还存在于主节点时，这个键在所有附属节点的副本也不会被删除。</p>
<p>这种处理机制对那些使用大量附属节点，并且带有大量过期键的应用来说，可能会造成一部分内存不能立即被释放，但是，因为过期键通常很快会被主节点发现并删除，所以这实际上也算不上什么大问题。</p>
</div>
</div>
<div class="section" id="db-expand-and-shrink">
<span id="id23"></span><h2>数据库空间的收缩和扩展<a class="headerlink" href="#db-expand-and-shrink" title="Permalink to this headline">¶</a></h2>
<p>因为数据库空间是由字典来实现的，
所以数据库空间的扩展/收缩规则和字典的扩展/收缩规则完全一样，
具体的信息可以参考《<a class="reference internal" href="../internal-datastruct/dict.html#dict-chapter"><span>字典</span></a>》章节。</p>
<p>因为对字典进行收缩的时机是由使用字典的程序决定的，
所以 Redis 使用 <code class="docutils literal"><span class="pre">redis.c/tryResizeHashTables</span></code> 函数来检查数据库所使用的字典是否需要进行收缩：
每次 <code class="docutils literal"><span class="pre">redis.c/serverCron</span></code> 函数运行的时候，
这个函数都会被调用。</p>
<p><code class="docutils literal"><span class="pre">tryResizeHashTables</span></code> 函数的完整定义如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * 对服务器中的所有数据库键空间字典、以及过期时间字典进行检查，</span>
<span class="cm"> * 看是否需要对这些字典进行收缩。</span>
<span class="cm"> *</span>
<span class="cm"> * 如果字典的使用空间比率低于 REDIS_HT_MINFILL</span>
<span class="cm"> * 那么将字典的大小缩小，让 USED/BUCKETS 的比率 &lt;= 1</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">tryResizeHashTables</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">dbnum</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 缩小键空间字典</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">htNeedsResize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dict</span><span class="p">))</span>
            <span class="n">dictResize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dict</span><span class="p">);</span>

        <span class="c1">// 缩小过期时间字典</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">htNeedsResize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">expires</span><span class="p">))</span>
            <span class="n">dictResize</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">db</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">expires</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h2>小结<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>数据库主要由 <code class="docutils literal"><span class="pre">dict</span></code> 和 <code class="docutils literal"><span class="pre">expires</span></code> 两个字典构成，其中 <code class="docutils literal"><span class="pre">dict</span></code> 保存键值对，而 <code class="docutils literal"><span class="pre">expires</span></code> 则保存键的过期时间。</li>
<li>数据库的键总是一个字符串对象，而值可以是任意一种 Redis 数据类型，包括字符串、哈希、集合、列表和有序集。</li>
<li><code class="docutils literal"><span class="pre">expires</span></code> 的某个键和 <code class="docutils literal"><span class="pre">dict</span></code> 的某个键共同指向同一个字符串对象，而 <code class="docutils literal"><span class="pre">expires</span></code> 键的值则是该键以毫秒计算的 UNIX 过期时间戳。</li>
<li>Redis 使用惰性删除和定期删除两种策略来删除过期的键。</li>
<li>更新后的 RDB 文件和重写后的 AOF 文件都不会保留已经过期的键。</li>
<li>当一个过期键被删除之后，程序会追加一条新的 <code class="docutils literal"><span class="pre">DEL</span></code> 命令到现有 AOF 文件末尾。</li>
<li>当主节点删除一个过期键之后，它会显式地发送一条 <code class="docutils literal"><span class="pre">DEL</span></code> 命令到所有附属节点。</li>
<li>附属节点即使发现过期键，也不会自作主张地删除它，而是等待主节点发来 <code class="docutils literal"><span class="pre">DEL</span></code> 命令，这样可以保证主节点和附属节点的数据总是一致的。</li>
<li>数据库的 <code class="docutils literal"><span class="pre">dict</span></code> 字典和 <code class="docutils literal"><span class="pre">expires</span></code> 字典的扩展策略和普通字典一样。它们的收缩策略是：当节点的填充百分比不足 10% 时，将可用节点数量减少至大于等于当前已用节点数量。</li>
</ul>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisbook'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="rdb.html" title="RDB"
             >next</a> |</li>
        <li class="right" >
          <a href="../feature/slowlog.html" title="慢查询日志"
             >previous</a> |</li>
        <li><a href="../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, huangz1990.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>