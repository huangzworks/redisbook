<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>事务 &mdash; Redis 设计与实现</title>
    
    <link rel="stylesheet" href="../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Redis 设计与实现" href="../index.html" />
    <link rel="next" title="订阅与发布" href="pubsub.html" />
    <link rel="prev" title="有序集" href="../datatype/sorted_set.html" /> 

<!--[if lte IE 6]>
<link rel="stylesheet" href="../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->


  </head>
  <body>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pubsub.html" title="订阅与发布"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../datatype/sorted_set.html" title="有序集"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>事务<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Redis 通过 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" title="(in Redis 命令参考 v2.8)"><em>DISCARD</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 和 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 四个命令来实现事务功能，
本章首先讨论使用 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" title="(in Redis 命令参考 v2.8)"><em>DISCARD</em></a> 和 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 三个命令实现的一般事务，
然后再来讨论带有 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 的事务的实现。</p>
<p>因为事务的安全性也非常重要，
所以本章最后通过常见的 ACID 性质对 Redis 事务的安全性进行了说明。</p>
<div class="section" id="id2">
<h2>事务<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>事务提供了一种“将多个命令打包，
然后一次性、按顺序地执行”的机制，
并且事务在执行的期间不会主动中断 ——
服务器在执行完事务中的所有命令之后，
才会继续处理其他客户端的其他命令。</p>
<p>以下是一个事务的例子，
它先以 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 开始一个事务，
然后将多个命令入队到事务中，
最后由 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 命令触发事务，
一并执行事务中的所有命令：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span> <span class="s">&quot;Mastering C++ in 21 days&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">tag</span> <span class="s">&quot;C++&quot;</span> <span class="s">&quot;Programming&quot;</span> <span class="s">&quot;Mastering Series&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">tag</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="mi">1</span><span class="p">)</span> <span class="n">OK</span>
<span class="mi">2</span><span class="p">)</span> <span class="s">&quot;Mastering C++ in 21 days&quot;</span>
<span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">integer</span><span class="p">)</span> <span class="mi">3</span>
<span class="mi">4</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;Mastering Series&quot;</span>
   <span class="mi">2</span><span class="p">)</span> <span class="s">&quot;C++&quot;</span>
   <span class="mi">3</span><span class="p">)</span> <span class="s">&quot;Programming&quot;</span>
</pre></div>
</div>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ol class="arabic simple">
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ol>
<p>下文将分别介绍事务的这三个阶段。</p>
</div>
<div class="section" id="id3">
<h2>开始事务<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 命令的执行标记着事务的开始：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>
</pre></div>
</div>
<p>这个命令唯一做的就是，
将客户端的 <code class="docutils literal"><span class="pre">REDIS_MULTI</span></code> 选项打开，
让客户端从非事务状态切换到事务状态。</p>
<p class="graphviz">
<img src="../_images/graphviz-0ff9f2e58803dbb8c1c400e1f8191f77d4c2917e.svg" alt="digraph normal_to_transaction {

    rankdir = LR;

    node [shape = circle, style = filled];

    edge [style = bold];

    label = &quot;客户端状态的切换&quot;;

    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];

    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];

    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];
}" />
</p>
</div>
<div class="section" id="id4">
<h2>命令入队<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>当客户端处于非事务状态下时，
所有发送给服务器端的命令都会立即被服务器执行：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s">&quot;hello moto&quot;</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">msg</span>
<span class="s">&quot;hello moto&quot;</span>
</pre></div>
</div>
<p>但是，
当客户端进入事务状态之后，
服务器在收到来自客户端的命令时，
不会立即执行命令，
而是将这些命令全部放进一个事务队列里，
然后返回 <code class="docutils literal"><span class="pre">QUEUED</span></code> ，
表示命令已入队：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">msg</span> <span class="s">&quot;hello moto&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">msg</span>
<span class="n">QUEUED</span>
</pre></div>
</div>
<p>以下流程图展示了这一行为：</p>
<p class="graphviz">
<img src="../_images/graphviz-8a0f8eae0bb8180e877b799921dd690267c2d3b4.svg" alt="digraph enqueue {

    node [shape = plaintext, style = filled];

    edge [style = bold];

    command_in [label = &quot;服务器接到来自客户端的命令&quot;];

    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];

    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];

    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];

    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];

    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];

    // 

    command_in -&gt; in_transaction_or_not;

    in_transaction_or_not -&gt; enqueu_command [label = &quot;是&quot;];

    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];

    exec_command -&gt; return_command_result;

    enqueu_command -&gt; return_enqueued;
}" />
</p>
<p>事务队列是一个数组，
每个数组项是都包含三个属性：</p>
<ol class="arabic simple">
<li>要执行的命令（cmd）。</li>
<li>命令的参数（argv）。</li>
<li>参数的个数（argc）。</li>
</ol>
<p>举个例子，
如果客户端执行以下命令：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span> <span class="s">&quot;Mastering C++ in 21 days&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">GET</span> <span class="n">book</span><span class="o">-</span><span class="n">name</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SADD</span> <span class="n">tag</span> <span class="s">&quot;C++&quot;</span> <span class="s">&quot;Programming&quot;</span> <span class="s">&quot;Mastering Series&quot;</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SMEMBERS</span> <span class="n">tag</span>
<span class="n">QUEUED</span>
</pre></div>
</div>
<p>那么程序将为客户端创建以下事务队列：</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="15%" />
<col width="58%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">数组索引</th>
<th class="head">cmd</th>
<th class="head">argv</th>
<th class="head">argc</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">SET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">GET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">SADD</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">Series&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">4</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">3</span></code></td>
<td><code class="docutils literal"><span class="pre">SMEMBERS</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id5">
<h2>执行事务<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>前面说到，
当客户端进入事务状态之后，
客户端发送的命令就会被放进事务队列里。</p>
<p>但其实并不是所有的命令都会被放进事务队列，
其中的例外就是 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" title="(in Redis 命令参考 v2.8)"><em>DISCARD</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 和 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 这四个命令 ——
当这四个命令从客户端发送到服务器时，
它们会像客户端处于非事务状态一样，
直接被服务器执行：</p>
<p class="graphviz">
<img src="../_images/graphviz-836c8a3dc33526a649d9ecf5b7b959d72b38cc7d.svg" alt="digraph not_enque_command {

    node [shape = plaintext, style = filled];

    edge [style = bold];

    command_in [label = &quot;服务器接到来自客户端的命令&quot;];

    in_transaction_or_not [label = &quot;客户端是否正处于事务状态？&quot;, shape = diamond, fillcolor = &quot;#95BBE3&quot;];

    not_exec_and_discard [label = &quot;命令是否\nEXEC 、 DISCARD 、\nMULTI 或 WATCH ？&quot;, shape = diamond, fillcolor = &quot;#FFC1C1&quot;];

    enqueu_command [label = &quot;将命令放进事务队列里&quot;, fillcolor = &quot;#A8E270&quot;];

    return_enqueued [label = &quot;向客户端返回 QUEUED 字符串\n表示命令已入队&quot;, fillcolor = &quot;#A8E270&quot;];

    exec_command [label = &quot;执行命令&quot;, fillcolor = &quot;#FADCAD&quot;];

    return_command_result [label = &quot;向客户端返回命令的执行结果&quot;, fillcolor = &quot;#FADCAD&quot;];

    // 

    command_in -&gt; in_transaction_or_not;

    in_transaction_or_not -&gt; not_exec_and_discard [label = &quot;是&quot;];

    not_exec_and_discard -&gt; enqueu_command [label = &quot;否&quot;];

    not_exec_and_discard -&gt; exec_command [label = &quot;是&quot;];

    in_transaction_or_not -&gt; exec_command [label = &quot;否&quot;];

    exec_command -&gt; return_command_result;

    enqueu_command -&gt; return_enqueued;
}" />
</p>
<p>如果客户端正处于事务状态，
那么当 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 命令执行时，
服务器根据客户端所保存的事务队列，
以先进先出（FIFO）的方式执行事务队列中的命令：
最先入队的命令最先执行，
而最后入队的命令最后执行。</p>
<p>比如说，对于以下事务队列：</p>
<table border="1" class="docutils">
<colgroup>
<col width="9%" />
<col width="15%" />
<col width="58%" />
<col width="18%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">数组索引</th>
<th class="head">cmd</th>
<th class="head">argv</th>
<th class="head">argc</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0</span></code></td>
<td><code class="docutils literal"><span class="pre">SET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">2</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1</span></code></td>
<td><code class="docutils literal"><span class="pre">GET</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;book-name&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">2</span></code></td>
<td><code class="docutils literal"><span class="pre">SADD</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;,</span> <span class="pre">&quot;Mastering</span> <span class="pre">Series&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">4</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">3</span></code></td>
<td><code class="docutils literal"><span class="pre">SMEMBERS</span></code></td>
<td><code class="docutils literal"><span class="pre">[&quot;tag&quot;]</span></code></td>
<td><code class="docutils literal"><span class="pre">1</span></code></td>
</tr>
</tbody>
</table>
<p>程序会首先执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/string/set.html#set" title="(in Redis 命令参考 v2.8)"><em>SET</em></a> 命令，
然后执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/string/get.html#get" title="(in Redis 命令参考 v2.8)"><em>GET</em></a> 命令，
再然后执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd" title="(in Redis 命令参考 v2.8)"><em>SADD</em></a> 命令，
最后执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/set/smembers.html#smembers" title="(in Redis 命令参考 v2.8)"><em>SMEMBERS</em></a> 命令。</p>
<p>执行事务中的命令所得的结果会以 FIFO 的顺序保存到一个回复队列中。</p>
<p>比如说，对于上面给出的事务队列，程序将为队列中的命令创建如下回复队列：</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="26%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">数组索引</th>
<th class="head">回复类型</th>
<th class="head">回复内容</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">0</span></code></td>
<td>status code reply</td>
<td><code class="docutils literal"><span class="pre">OK</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">1</span></code></td>
<td>bulk reply</td>
<td><code class="docutils literal"><span class="pre">&quot;Mastering</span> <span class="pre">C++</span> <span class="pre">in</span> <span class="pre">21</span> <span class="pre">days&quot;</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">2</span></code></td>
<td>integer reply</td>
<td><code class="docutils literal"><span class="pre">3</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">3</span></code></td>
<td>multi-bulk reply</td>
<td><code class="docutils literal"><span class="pre">[&quot;Mastering</span> <span class="pre">Series&quot;,</span> <span class="pre">&quot;C++&quot;,</span> <span class="pre">&quot;Programming&quot;]</span></code></td>
</tr>
</tbody>
</table>
<p>当事务队列里的所有命令被执行完之后，
<a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 命令会将回复队列作为自己的执行结果返回给客户端，
客户端从事务状态返回到非事务状态，
至此，
事务执行完毕。</p>
<p>事务的整个执行过程可以用以下伪代码表示：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">execute_transaction</span><span class="p">():</span>

    <span class="c"># 创建空白的回复队列</span>
    <span class="n">reply_queue</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># 取出事务队列里的所有命令、参数和参数数量</span>
    <span class="k">for</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span> <span class="ow">in</span> <span class="n">client</span><span class="o">.</span><span class="n">transaction_queue</span><span class="p">:</span>

        <span class="c"># 执行命令，并取得命令的返回值</span>
        <span class="n">reply</span> <span class="o">=</span> <span class="n">execute_redis_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span><span class="p">)</span>

        <span class="c"># 将返回值追加到回复队列末尾</span>
        <span class="n">reply_queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reply</span><span class="p">)</span>

    <span class="c"># 清除客户端的事务状态</span>
    <span class="n">clear_transaction_state</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

    <span class="c"># 清空事务队列</span>
    <span class="n">clear_transaction_queue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>

    <span class="c"># 将事务的执行结果返回给客户端</span>
    <span class="n">send_reply_to_client</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">reply_queue</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2>在事务和非事务状态下执行命令<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>无论在事务状态下，
还是在非事务状态下，
Redis 命令都由同一个函数执行，
所以它们共享很多服务器的一般设置，
比如 AOF 的配置、RDB 的配置，以及内存限制，等等。</p>
<p>不过事务中的命令和普通命令在执行上还是有一点区别的，其中最重要的两点是：</p>
<ol class="arabic">
<li><p class="first">非事务状态下的命令以单个命令为单位执行，前一个命令和后一个命令的客户端不一定是同一个；</p>
<p>而事务状态则是以一个事务为单位，执行事务队列中的所有命令：除非当前事务执行完毕，否则服务器不会中断事务，也不会执行其他客户端的其他命令。</p>
</li>
<li><p class="first">在非事务状态下，执行命令所得的结果会立即被返回给客户端；</p>
<p>而事务则是将所有命令的结果集合到回复队列，再作为 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 命令的结果返回给客户端。</p>
</li>
</ol>
</div>
<div class="section" id="discard-multi-watch">
<h2>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令<a class="headerlink" href="#discard-multi-watch" title="Permalink to this headline">¶</a></h2>
<p>除了 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 之外，
服务器在客户端处于事务状态时，
不加入到事务队列而直接执行的另外三个命令是 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" title="(in Redis 命令参考 v2.8)"><em>DISCARD</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 和 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 。</p>
<p><a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/discard.html#discard" title="(in Redis 命令参考 v2.8)"><em>DISCARD</em></a> 命令用于取消一个事务，
它清空客户端的整个事务队列，
然后将客户端从事务状态调整回非事务状态，
最后返回字符串 <code class="docutils literal"><span class="pre">OK</span></code> 给客户端，
说明事务已被取消。</p>
<p>Redis 的事务是不可嵌套的，
当客户端已经处于事务状态，
而客户端又再向服务器发送 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 时，
服务器只是简单地向客户端发送一个错误，
然后继续等待其他命令的入队。
<a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 命令的发送不会造成整个事务失败，
也不会修改事务队列中已有的数据。</p>
<p><a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 只能在客户端进入事务状态之前执行，
在事务状态下发送 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 命令会引发一个错误，
但它不会造成整个事务失败，
也不会修改事务队列中已有的数据（和前面处理 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/multi.html#multi" title="(in Redis 命令参考 v2.8)"><em>MULTI</em></a> 的情况一样）。</p>
</div>
<div class="section" id="watch">
<h2>带 WATCH 的事务<a class="headerlink" href="#watch" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 命令用于在事务开始之前监视任意数量的键：
当调用 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 命令执行事务时，
如果任意一个被监视的键已经被其他客户端修改了，
那么整个事务不再执行，
直接返回失败。</p>
<p>以下示例展示了一个执行失败的事务例子：</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">redis</span><span class="o">&gt;</span> <span class="n">WATCH</span> <span class="n">name</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">MULTI</span>
<span class="n">OK</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">name</span> <span class="n">peter</span>
<span class="n">QUEUED</span>

<span class="n">redis</span><span class="o">&gt;</span> <span class="n">EXEC</span>
<span class="p">(</span><span class="n">nil</span><span class="p">)</span>
</pre></div>
</div>
<p>以下执行序列展示了上面的例子是如何失败的：</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="45%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">时间</th>
<th class="head">客户端 A</th>
<th class="head">客户端 B</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>T1</td>
<td><code class="docutils literal"><span class="pre">WATCH</span> <span class="pre">name</span></code></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>T2</td>
<td><code class="docutils literal"><span class="pre">MULTI</span></code></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>T3</td>
<td><code class="docutils literal"><span class="pre">SET</span> <span class="pre">name</span> <span class="pre">peter</span></code></td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>T4</td>
<td>&nbsp;</td>
<td><code class="docutils literal"><span class="pre">SET</span> <span class="pre">name</span> <span class="pre">john</span></code></td>
</tr>
<tr class="row-even"><td>T5</td>
<td><code class="docutils literal"><span class="pre">EXEC</span></code></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>在时间 T4 ，客户端 B 修改了 <code class="docutils literal"><span class="pre">name</span></code> 键的值，
当客户端 A 在 T5 执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 时，Redis 会发现 <code class="docutils literal"><span class="pre">name</span></code> 这个被监视的键已经被修改，
因此客户端 A 的事务不会被执行，而是直接返回失败。</p>
<p>下文就来介绍 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 的实现机制，并且看看事务系统是如何检查某个被监视的键是否被修改，从而保证事务的安全性的。</p>
</div>
<div class="section" id="id7">
<h2>WATCH 命令的实现<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>在每个代表数据库的 <code class="docutils literal"><span class="pre">redis.h/redisDb</span></code> 结构类型中，
都保存了一个 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典，
字典的键是这个数据库被监视的键，
而字典的值则是一个链表，
链表中保存了所有监视这个键的客户端。</p>
<p>比如说，以下字典就展示了一个 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典的例子：</p>
<p class="graphviz">
<img src="../_images/graphviz-9aea81f33da1373550c590eb0b7ca0c2b3d38366.svg" alt="digraph watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}" />
</p>
<p>其中， 键 <code class="docutils literal"><span class="pre">key1</span></code> 正在被 <code class="docutils literal"><span class="pre">client2</span></code> 、 <code class="docutils literal"><span class="pre">client5</span></code> 和 <code class="docutils literal"><span class="pre">client1</span></code> 三个客户端监视，
其他一些键也分别被其他别的客户端监视着。</p>
<p><a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/watch.html#watch" title="(in Redis 命令参考 v2.8)"><em>WATCH</em></a> 命令的作用，
就是将当前客户端和要监视的键在 <code class="docutils literal"><span class="pre">watched_keys</span></code> 中进行关联。</p>
<p>举个例子，
如果当前客户端为 <code class="docutils literal"><span class="pre">client10086</span></code> ，
那么当客户端执行 <code class="docutils literal"><span class="pre">WATCH</span> <span class="pre">key1</span> <span class="pre">key2</span></code> 时，
前面展示的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 将被修改成这个样子：</p>
<p class="graphviz">
<img src="../_images/graphviz-fe5e31054c282a3cdd86656994fe1678a3d4f201.svg" alt="digraph new_watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    client10086 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; client10086;
    client10086 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    client10086_2 [label = &quot;client10086&quot;, fillcolor = &quot;#FFC1C1&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; client10086_2;
    client10086_2 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}" />
</p>
<p>通过 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典，
如果程序想检查某个键是否被监视，
那么它只要检查字典中是否存在这个键即可；
如果程序要获取监视某个键的所有客户端，
那么只要取出键的值（一个链表），
然后对链表进行遍历即可。</p>
</div>
<div class="section" id="id8">
<h2>WATCH 的触发<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>在任何对数据库键空间（key space）进行修改的命令成功执行之后
（比如 <a class="reference external" href="http://redis.readthedocs.org/en/latest/server/flushdb.html#flushdb" title="(in Redis 命令参考 v2.8)"><em>FLUSHDB</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/string/set.html#set" title="(in Redis 命令参考 v2.8)"><em>SET</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/key/del.html#del" title="(in Redis 命令参考 v2.8)"><em>DEL</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/list/lpush.html#lpush" title="(in Redis 命令参考 v2.8)"><em>LPUSH</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/set/sadd.html#sadd" title="(in Redis 命令参考 v2.8)"><em>SADD</em></a> 、 <a class="reference external" href="http://redis.readthedocs.org/en/latest/sorted_set/zrem.html#zrem" title="(in Redis 命令参考 v2.8)"><em>ZREM</em></a> ，诸如此类），
<code class="docutils literal"><span class="pre">multi.c/touchWatchedKey</span></code> 函数都会被调用 ——
它检查数据库的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典，
看是否有客户端在监视已经被命令修改的键，
如果有的话，
程序将所有监视这个/这些被修改键的客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项打开：</p>
<p class="graphviz">
<img src="../_images/graphviz-e5c66122242aa10939b696dfeeb905343c5202bd.svg" alt="digraph dirty_cas {

    rankdir = LR;

    node [shape = circle, style = filled];

    edge [style = bold];

    label = &quot;客户端状态的切换&quot;;

    normal [label = &quot;非事务状态&quot;, fillcolor = &quot;#FADCAD&quot;];

    transaction [label = &quot;事务状态&quot;, fillcolor = &quot;#A8E270&quot;];

    dirty_cas [label = &quot;事务安全性\n已被破坏&quot;, fillcolor = &quot;#B22222&quot;];

    normal -&gt; transaction [label = &quot;打开选项\nREDIS_MULTI&quot;];

    transaction -&gt; dirty_cas [label = &quot;打开选项\nREDIS_DIRTY_CAS&quot;];
}" />
</p>
<p>当客户端发送 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 命令、触发事务执行时，
服务器会对客户端的状态进行检查：</p>
<ul class="simple">
<li>如果客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项已经被打开，那么说明被客户端监视的键至少有一个已经被修改了，事务的安全性已经被破坏。服务器会放弃执行这个事务，直接向客户端返回空回复，表示事务执行失败。</li>
<li>如果 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项没有被打开，那么说明所有监视键都安全，服务器正式执行事务。</li>
</ul>
<p>可以用一段伪代码来表示这个检查：</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">check_safety_before_execute_trasaction</span><span class="p">():</span>

    <span class="k">if</span> <span class="n">client</span><span class="o">.</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">REDIS_DIRTY_CAS</span><span class="p">:</span>
        <span class="c"># 安全性已破坏，清除事务状态</span>
        <span class="n">clear_transaction_state</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
        <span class="c"># 清空事务队列</span>
        <span class="n">clear_transaction_queue</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
        <span class="c"># 返回空回复给客户端</span>
        <span class="n">send_empty_reply</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># 安全性完好，执行事务</span>
        <span class="n">execute_transaction</span><span class="p">()</span>
</pre></div>
</div>
<p>举个例子，假设数据库的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典如下图所示：</p>
<p class="graphviz">
<img src="../_images/graphviz-9aea81f33da1373550c590eb0b7ca0c2b3d38366.svg" alt="digraph watched_keys {

    rankdir = LR;

    node [shape = record, style = filled];

    edge [style = bold];

    // keys

    watched_keys [label = &quot;watched_keys |&lt;key1&gt; key1 |&lt;key2&gt; key2 |&lt;key3&gt; key3 | ... |&lt;keyN&gt; keyN&quot;, fillcolor = &quot;#A8E270&quot;];

    // clients blocking for key1
    client1 [label = &quot;client1&quot;, fillcolor = &quot;#95BBE3&quot;];
    client5 [label = &quot;client5&quot;, fillcolor = &quot;#95BBE3&quot;];
    client2 [label = &quot;client2&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_1 [label = &quot;NULL&quot;, shape = plaintext];
    
    watched_keys:key1 -&gt; client2;
    client2 -&gt; client5;
    client5 -&gt; client1;
    client1 -&gt; null_1;

    // clients blocking for key2
    client7 [label = &quot;client7&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_2 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key2 -&gt; client7;
    client7 -&gt; null_2;

    // key3

    client3 [label = &quot;client3&quot;, fillcolor = &quot;#95BBE3&quot;];
    client4 [label = &quot;client4&quot;, fillcolor = &quot;#95BBE3&quot;];
    client6 [label = &quot;client6&quot;, fillcolor = &quot;#95BBE3&quot;];
    null_3 [label = &quot;NULL&quot;, shape = plaintext];

    watched_keys:key3 -&gt; client3;
    client3 -&gt; client4;
    client4 -&gt; client6;
    client6 -&gt; null_3;
}" />
</p>
<p>如果某个客户端对 <code class="docutils literal"><span class="pre">key1</span></code> 进行了修改（比如执行 <code class="docutils literal"><span class="pre">DEL</span> <span class="pre">key1</span></code> ），
那么所有监视 <code class="docutils literal"><span class="pre">key1</span></code> 的客户端，
包括 <code class="docutils literal"><span class="pre">client2</span></code> 、 <code class="docutils literal"><span class="pre">client5</span></code> 和 <code class="docutils literal"><span class="pre">client1</span></code> 的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项都会被打开，
当客户端 <code class="docutils literal"><span class="pre">client2</span></code> 、 <code class="docutils literal"><span class="pre">client5</span></code> 和 <code class="docutils literal"><span class="pre">client1</span></code> 执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 的时候，
它们的事务都会以失败告终。</p>
<p>最后，当一个客户端结束它的事务时，无论事务是成功执行，还是失败， <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典中和这个客户端相关的资料都会被清除。</p>
</div>
<div class="section" id="acid">
<h2>事务的 ACID 性质<a class="headerlink" href="#acid" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">勘误：Redis 的事务是保证原子性的，本节的内容将原子性和回滚功能混淆了，等待修复中。 —— 2013.6.23</p>
</div>
<p>在传统的关系式数据库中，常常用 <a class="reference external" href="http://en.wikipedia.org/wiki/ACID">ACID 性质</a>来检验事务功能的安全性。</p>
<p>Redis 事务保证了其中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</p>
<p>以下四小节是关于这四个性质的详细讨论。</p>
<div class="section" id="atomicity">
<h3>原子性（Atomicity）<a class="headerlink" href="#atomicity" title="Permalink to this headline">¶</a></h3>
<p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>
<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>
<p>当事务失败时，Redis 也不会进行任何的重试或者回滚动作。</p>
</div>
<div class="section" id="consistency">
<h3>一致性（Consistency）<a class="headerlink" href="#consistency" title="Permalink to this headline">¶</a></h3>
<p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p>
<div class="section" id="id10">
<h4>入队错误<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>在命令入队的过程中，如果客户端向服务器发送了错误的命令，比如命令的参数数量不对，等等，
那么服务器将向客户端返回一个出错信息，
并且将客户端的事务状态设为 <code class="docutils literal"><span class="pre">REDIS_DIRTY_EXEC</span></code> 。</p>
<p>当客户端执行 <a class="reference external" href="http://redis.readthedocs.org/en/latest/transaction/exec.html#exec" title="(in Redis 命令参考 v2.8)"><em>EXEC</em></a> 命令时，
Redis 会拒绝执行状态为 <code class="docutils literal"><span class="pre">REDIS_DIRTY_EXEC</span></code> 的事务，
并返回失败信息。</p>
<div class="highlight-c"><div class="highlight"><pre>redis 127.0.0.1:6379&gt; MULTI
OK

redis 127.0.0.1:6379&gt; set key
(error) ERR wrong number of arguments for &#39;set&#39; command

redis 127.0.0.1:6379&gt; EXISTS key
QUEUED

redis 127.0.0.1:6379&gt; EXEC
(error) EXECABORT Transaction discarded because of previous errors.
</pre></div>
</div>
<p>因此，带有不正确入队命令的事务不会被执行，也不会影响数据库的一致性。</p>
</div>
<div class="section" id="id11">
<h4>执行错误<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>如果命令在事务执行的过程中发生错误，比如说，对一个不同类型的 key 执行了错误的操作，
那么 Redis 只会将错误包含在事务的结果中，
这不会引起事务中断或整个失败，不会影响已执行事务命令的结果，也不会影响后面要执行的事务命令，
所以它对事务的一致性也没有影响。</p>
</div>
<div class="section" id="redis">
<h4>Redis 进程被终结<a class="headerlink" href="#redis" title="Permalink to this headline">¶</a></h4>
<p>如果 Redis 服务器进程在执行事务的过程中被其他进程终结，或者被管理员强制杀死，那么根据 Redis 所使用的持久化模式，可能有以下情况出现：</p>
<ul>
<li><p class="first">内存模式：如果 Redis 没有采取任何持久化机制，那么重启之后的数据库总是空白的，所以数据总是一致的。</p>
</li>
<li><p class="first">RDB 模式：在执行事务时，Redis 不会中断事务去执行保存 RDB 的工作，只有在事务执行之后，保存 RDB 的工作才有可能开始。所以当 RDB 模式下的 Redis 服务器进程在事务中途被杀死时，事务内执行的命令，不管成功了多少，都不会被保存到 RDB 文件里。恢复数据库需要使用现有的 RDB 文件，而这个 RDB 文件的数据保存的是最近一次的数据库快照（snapshot），所以它的数据可能不是最新的，但只要 RDB 文件本身没有因为其他问题而出错，那么还原后的数据库就是一致的。</p>
</li>
<li><p class="first">AOF 模式：因为保存 AOF 文件的工作在后台线程进行，所以即使是在事务执行的中途，保存 AOF 文件的工作也可以继续进行，因此，根据事务语句是否被写入并保存到 AOF 文件，有以下两种情况发生：</p>
<p>1）如果事务语句未写入到 AOF 文件，或 AOF 未被 SYNC 调用保存到磁盘，那么当进程被杀死之后，Redis 可以根据最近一次成功保存到磁盘的 AOF 文件来还原数据库，只要 AOF 文件本身没有因为其他问题而出错，那么还原后的数据库总是一致的，但其中的数据不一定是最新的。</p>
<p>2）如果事务的部分语句被写入到 AOF 文件，并且 AOF 文件被成功保存，那么不完整的事务执行信息就会遗留在 AOF 文件里，当重启 Redis 时，程序会检测到 AOF 文件并不完整，Redis 会退出，并报告错误。需要使用 redis-check-aof 工具将部分成功的事务命令移除之后，才能再次启动服务器。还原之后的数据总是一致的，而且数据也是最新的（直到事务执行之前为止）。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="isolation">
<h3>隔离性（Isolation）<a class="headerlink" href="#isolation" title="Permalink to this headline">¶</a></h3>
<p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
</div>
<div class="section" id="durability">
<h3>持久性（Durability）<a class="headerlink" href="#durability" title="Permalink to this headline">¶</a></h3>
<p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>
<ul>
<li><p class="first">在单纯的内存模式下，事务肯定是不持久的。</p>
</li>
<li><p class="first">在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p>
</li>
<li><p class="first">在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 <code class="docutils literal"><span class="pre">fsync</span></code> 或 <code class="docutils literal"><span class="pre">fdatasync</span></code> 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>
<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>
</li>
</ul>
</div>
</div>
<div class="section" id="id12">
<h2>小结<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li>
<li>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li>
<li>带 <code class="docutils literal"><span class="pre">WATCH</span></code> 命令的事务会将客户端和被监视的键在数据库的 <code class="docutils literal"><span class="pre">watched_keys</span></code> 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项打开。</li>
<li>只有在客户端的 <code class="docutils literal"><span class="pre">REDIS_DIRTY_CAS</span></code> 选项未被打开时，才能执行事务，否则事务直接返回失败。</li>
<li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li>
</ul>
</div>
</div>



            <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'redisbook'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pubsub.html" title="订阅与发布"
             >next</a> |</li>
        <li class="right" >
          <a href="../datatype/sorted_set.html" title="有序集"
             >previous</a> |</li>
        <li><a href="../index.html">Redis 设计与实现</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, huangz1990.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3b1.
    </div>
  </body>
</html>